
# 구름 데이터 시각화 시스템 기술 문서

---

## 1. 프로젝트 배경 및 요구사항

### 1.1 데이터 특성

- **출처**: 기상청 API를 통해 제공되는 위성 관측 데이터.
- **형식**: NetCDF (`.nc`) 파일 형식으로 제공되며, 기상 데이터를 효율적으로 표현하기 위한 표준 형식.
- **그리드 크기**: 900x900 그리드 데이터로, 한반도를 중심으로 하는 정사각형 격자.
- **데이터 크기**:
  - 압축 전: 약 32MB
  - 압축 후: 10~12MB (gzip 기준)
- **데이터 구성**:
  - 각 그리드 포인트에 `cloud_status` (구름 상태) 값 저장.
  - 시간별(10분 간격)로 데이터 갱신.
  - 좌표 체계: EPSG:4326 (WGS84).

---

### 1.2 핵심 요구사항

1. **실시간 데이터 업데이트**:
   - 10분 주기로 데이터 갱신.
   - 지도에 최신 데이터가 반영되도록 구현.

2. **부드러운 시각화**:
   - WebGL을 활용하여 60fps의 부드러운 인터랙션을 목표.
   - 확대/축소 및 이동 시 부드러운 전환 지원.

3. **통계 데이터 통합**:
   - 지도 위에 발전량, 기상 통계 등 추가 정보를 함께 표현.
   - 툴팁 및 클릭 이벤트와 같은 사용자 인터랙션 제공.

4. **폐쇄망 환경 지원**:
   - 외부 네트워크 없이 동작 가능한 시스템 구축.
   - 오픈소스 라이브러리로만 구현.

---

## 2. 지도 라이브러리 선정

### 2.1 MapLibre 선택 이유

1. **라이센스**:
   - BSD 2-Clause 라이센스로 완전한 오픈소스 제공.
   - 상업적 사용과 배포에 제한 없음.
   - Mapbox GL JS 유료화 이후 현실적인 대안.

2. **React 호환성**:
   - `react-map-gl`과 같은 래퍼를 통해 React 컴포넌트와 쉽게 통합 가능.
   - 선언적 API 스타일로 상태 관리와 쉽게 통합.

3. **성능**:
   - WebGL 기반으로 고성능 벡터 타일 렌더링 지원.
   - 메모리와 GPU 자원을 효율적으로 활용하여 대규모 데이터 처리 가능.

---

### 2.2 대안 비교

| **특성**         | **MapLibre** | **OpenLayers** | **Leaflet** |
|-------------------|--------------|----------------|-------------|
| **라이센스**     | BSD 2-Clause | BSD 2-Clause   | BSD 2-Clause |
| **성능**         | 높음         | 중간           | 중간        |
| **React 통합**   | 우수         | 보통           | 보통        |
| **학습 곡선**    | 중간         | 가파름         | 완만        |
| **WebGL 지원**   | 기본         | 부분적         | 플러그인 필요 |

---

## 3. 데이터 시각화 전략

### 3.1 Vector Tiles vs Raster Tiles

#### Vector Tiles

- **장점**:
  - 동적 스타일링 가능 (색상, 크기 등 변경 용이).
  - 줌 레벨에서 선명한 렌더링.
  - 클라이언트에서 데이터 조작 용이.

- **단점**:
  - 초기 로딩 시간 증가.
  - 클라이언트의 CPU 및 GPU 리소스 사용량 증가.

#### Raster Tiles

- **장점**:
  - 빠른 초기 로딩 속도.
  - 서버 부하 분산 가능 (이미지 캐싱).
  - 낮은 클라이언트 리소스 사용량.

- **단점**:
  - 동적 스타일링 제한.
  - 줌 레벨에서 픽셀화 발생.
  - 서버의 저장 공간 요구량 증가.

---

### 3.2 Deck.gl 선택 이유

1. **성능**:
   - WebGL 기반으로 GPU를 활용한 고성능 데이터 렌더링 지원.
   - 대규모 데이터를 부드럽게 처리 가능.

2. **유연성**:
   - 다양한 데이터 포맷 지원 (JSON, GeoJSON, 바이너리 등).
   - 사용자 정의 레이어 생성 가능.
   - 기존 지도 라이브러리(MapLibre)와 쉽게 통합.

3. **React 호환성**:
   - React 컴포넌트와 통합하여 상태 기반 선언적 렌더링 가능.

---

## 4. 프론트엔드 구현

### 4.1 컴포넌트 구조

```plaintext
App
├── MapContainer
│   ├── Map (MapLibre 기반 지도 컴포넌트)
│   ├── DataLayer (Deck.gl을 사용한 데이터 시각화)
│   └── StatsOverlay (발전량 통계 및 툴팁)
└── Sidebar
    ├── Legend (범례)
    ├── Controls (데이터 필터링 및 줌 컨트롤)
```

---

### 4.2 성능 최적화

1. **데이터 최적화**:
   - 필요하지 않은 속성을 제거하여 데이터 크기 축소.
   - 위경도 좌표를 계산하는 방식으로 전송량 감소.

2. **렌더링 최적화**:
   - WebGL 컨텍스트 관리: 불필요한 레이어 렌더링 방지.
   - 레이어 업데이트 최소화: 데이터 변경 시에만 재렌더링.
   - 뷰포트 기반 데이터 필터링: 현재 화면에 표시되는 데이터만 렌더링.

3. **로딩 최적화**:
   - 초기 로딩 시, 낮은 해상도의 데이터를 먼저 로드하고 점진적으로 상세 데이터를 로드.

---

## 5. 성능 최적화

### 5.1 데이터 최적화

- **필터링**: 사용하지 않는 데이터 속성 및 영역을 제거.
- **좌표 정밀도 조정**: 소수점 정밀도를 줄여 데이터 크기 감소.
- **압축**: gzip 또는 brotli 압축을 사용하여 데이터 전송량 최적화.

---

### 5.2 렌더링 최적화

- **WebGL 컨텍스트 관리**:
  - WebGL 컨텍스트를 재사용하여 성능 향상.
  - Deck.gl 레이어 업데이트 최소화.
- **뷰포트 기반 필터링**:
  - 현재 화면에 보이는 영역만 데이터를 로드 및 렌더링.

---

## 6. 결론 및 교훈

### 6.1 주요 의사결정 포인트

1. **지도 라이브러리 선정**:
   - MapLibre와 Deck.gl의 조합으로 성능과 유연성의 최적 균형을 달성.
   - 완전한 오픈소스 생태계 활용으로 라이센스 리스크 제거.

2. **데이터 시각화 방식**:
   - 벡터 타일 방식을 채택하여 동적 데이터 처리와 사용자 인터랙션 지원.
   - 클라이언트의 성능을 고려한 뷰포트 기반 데이터 로딩.

---

### 6.2 앞으로의 개선점

- **데이터 파이프라인 최적화**:
  - 데이터 갱신 주기를 더욱 최적화하여 실시간성 강화.
- **사용자 경험 개선**:
  - 로딩 시 진행 상황 표시 및 사용자 인터랙션 향상.
- **확장 가능성 고려**:
  - 발전량 통계와 같은 추가적인 데이터 소스를 통합할 수 있도록 시스템 확장성 확보.

---
